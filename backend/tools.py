import datetime
import secrets
from functools import wraps
from typing import Generator
import groq
import jwt
from flask import request, jsonify
from pymongo import collection
from GPT.main import handle_message
from GPT.secrets import contains_secret
from dotenv import load_dotenv
import os


def stream_response(message: str, file_name: str, file_content: str, client: groq.Client, session_id: str, collectionGPT: collection.Collection) -> Generator[str, None, None]:
    """
    Generates a streaming response from the model by processing the incoming message
    and yielding chunks of the response. Each chunk is checked for security-related content.

    The function handles tokenized responses, yielding each chunk one at a time while ensuring
    the response does not exceed a defined token limit. If an illegal response (e.g., containing
    secret patterns) is detected, it immediately stops and yields an error message.

    :param message: The input message that will be sent to the model for processing.
    :param file_name: The name of the file to be processed, if provided.
    :param file_content: The content of the file to be processed, if provided.

    :yield: Chunks of the response generated by the model. If an error occurs or an illegal response is detected, an error message is yielded.
    """
    bot_response = ""
    token_queue = []
    TOKEN_LIMIT = 30

    try:
        for chunk in handle_message(message, file_name, file_content, client, session_id, collectionGPT):
            if not chunk:
                continue

            token_queue.append(chunk)
            concatenated_tokens = ''.join(token_queue)

            if contains_secret(concatenated_tokens):
                yield "***ERROR***: Illegal model response"
                return

            if len(token_queue) > TOKEN_LIMIT:
                oldest_chunk = token_queue.pop(0)
                bot_response += oldest_chunk
                yield oldest_chunk

        while token_queue:
            remaining_chunk = token_queue.pop(0)
            bot_response += remaining_chunk
            yield remaining_chunk

    except Exception as e:
        yield f"***ERROR***: {str(e)}"


def generate_jwt(session_id: str) -> str:
    payload = {
        'session_id': session_id,
        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=24)
    }

    load_dotenv()
    
    secret_key = os.getenv('SECRET_KEY')
    if not secret_key:
        raise ValueError("SECRET_KEY not found in environment variables")
        
    return jwt.encode(payload, secret_key, algorithm='HS256')

def verify_jwt(token: str) -> str | None:
    """
    Verify and decode a JWT token.
    
    Args:
        token (str): The JWT token to verify, should include 'Bearer ' prefix
        
    Returns:
        str | None: The session ID if token is valid, None otherwise
    """
    
    load_dotenv()
    
    secret_key = os.getenv('SECRET_KEY')
    if not secret_key:
        raise ValueError("SECRET_KEY not found in environment variables")
    
    try:
        if not token or not token.startswith('Bearer '):
            return None
            
        stripped_token = token.split('Bearer ')[1].strip()
        decoded = jwt.decode(stripped_token, secret_key, algorithms=['HS256'])
        return decoded.get('session_id')
        
    except (jwt.ExpiredSignatureError, jwt.InvalidTokenError):
        return None

def require_valid_token(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        token = request.headers.get('Authorization')
        session_id = verify_jwt(token)
        
        if not session_id:
            return jsonify({
                "error": "Authentication failed",
                "message": "Invalid or expired token"
            }), 401
            
        return f(session_id, *args, **kwargs)
    return decorated
